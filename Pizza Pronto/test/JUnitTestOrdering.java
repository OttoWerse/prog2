import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.time.DateTimeException;import java.time.LocalDate;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.List;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.platform.commons.support.ReflectionSupport;import de.thb.dim.pizzaPronto.businessObjects.Delivery;import de.thb.dim.pizzaPronto.businessObjects.IService;import de.thb.dim.pizzaPronto.businessObjects.Kitchen;import de.thb.dim.pizzaPronto.businessObjects.Ordering;import de.thb.dim.pizzaPronto.businessObjects.exceptions.NoCustomerException;import de.thb.dim.pizzaPronto.businessObjects.exceptions.NoOrderException;import de.thb.dim.pizzaPronto.valueObjects.CustomerVO;import de.thb.dim.pizzaPronto.valueObjects.DessertVO;import de.thb.dim.pizzaPronto.valueObjects.DishVO;import de.thb.dim.pizzaPronto.valueObjects.Gender;import de.thb.dim.pizzaPronto.valueObjects.OrderVO;import de.thb.dim.pizzaPronto.valueObjects.PastaVO;import de.thb.dim.pizzaPronto.valueObjects.PizzaVO;import de.thb.dim.pizzaPronto.valueObjects.StateOfOrderVO;import de.thb.dim.pizzaPronto.valueObjects.exceptions.CustomerTooYoungException;/** * EmployeeVO and work are tested. *  * Requirement: OrderVO and menuVO are ok *  * Special assert statements are used for testing <br> *  * @author Gabriele Schmidt * @version 2.0 03.04.2019 */public class JUnitTestOrdering { 	private static Class<Ordering> myOrderingClass;	private static OrderVO myOrder;	private static OrderVO myOrderWithoutCustomer;	private static Ordering myOrdering;	private static IService[] services = new IService[2];	private static CustomerVO customer;	private static Field nextId;	private static int modifiersNextId;	private static Field menu;	private static int modifiersMenu;		private static Method startSercice;	private static int modifiersStartService;	private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();	private final ByteArrayOutputStream errContent = new ByteArrayOutputStream();	private final PrintStream originalOut = System.out;	private final PrintStream originalErr = System.err;	@BeforeEach	public void initEach() throws NoSuchFieldException, NoSuchMethodException, SecurityException, NullPointerException, CustomerTooYoungException {		int year, number;		// create chef		services[0] = new Kitchen();		// create delivery man		services[1] = new Delivery();		// create customer		customer = new CustomerVO("Genuss", "Gini", "Haribostra√üe", 32, Gender.F, LocalDate.of(1995, 8, 8));		// create order		year = LocalDate.now().getYear();		number = year * 100000 + 1;		myOrder = new OrderVO(number, StateOfOrderVO.STARTED, LocalDateTime.now(), customer);		customer.setOrder(myOrder);		myOrderWithoutCustomer = new OrderVO(number, StateOfOrderVO.STARTED, LocalDateTime.now(), null);		myOrdering = new Ordering();				myOrderingClass =  Ordering.class;				startSercice = myOrderingClass.getDeclaredMethod("startService");		modifiersStartService = startSercice.getModifiers();		}	// Ordering	@Test	public void testOrderingCreateMenu() {		assertNotNull(Ordering.getMenu(), "Attribut menu of Ordering is not null");		;	}	public void testOrderingMenu() throws NoSuchFieldException, SecurityException {		myOrderingClass = Ordering.class;		menu = myOrderingClass.getDeclaredField("menu");		modifiersMenu = menu.getModifiers();		assertTrue(Modifier.isPrivate(modifiersMenu), "Attribut menu of Ordering is private");		assertTrue(Modifier.isStatic(modifiersMenu), "Attribut menu of Ordering is static");	}	@Test	public void testOrderingNextId() throws NoSuchFieldException, SecurityException {		myOrderingClass = Ordering.class;		nextId = myOrderingClass.getDeclaredField("nextId");		modifiersNextId = nextId.getModifiers();		assertTrue(Modifier.isPrivate(modifiersNextId), "Attribut nextId of Ordering is private");		assertTrue(Modifier.isStatic(modifiersNextId), "Attribut nextId of Ordering is static");	}	@Test	public void testOrderingNextId0()			throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {		int id = 0;		Ordering myOrderingId = new Ordering();		myOrderingClass = Ordering.class;		nextId = myOrderingClass.getDeclaredField("nextId");		nextId.setAccessible(true);		nextId.set(0, 0);		assertTrue(id == Ordering.getNextId(), "NexID is 0");		myOrderingId.startNewOrder(customer);		id = LocalDateTime.now().getYear() * 100000 + 1;		assertTrue(id == myOrderingId.getCurrentOrder().getOrderNo(), "OrderNo of currentOrder is correct");		assertTrue(id == Ordering.getNextId(), "NextId of Ordering is correct");	}	@Test	public void testOrderingNextIdIncrement() throws NoSuchFieldException, SecurityException {		int id;		Ordering myOrderingId = new Ordering();		id = Ordering.getNextId();		for (int i = 0; i < 20; i++) {			myOrderingId.startNewOrder(customer);			id++;			assertTrue(id == Ordering.getNextId(), "NextId of Ordering is correct");		}	}	@Test	public void testOrderingKonstruktor() {		OrderVO order;		CustomerVO customer;		IService services[] = new IService[2];		myOrdering = new Ordering();		order = myOrdering.getCurrentOrder();		assertNull(order, "Order is null");		customer = myOrdering.getCurrentCustomer();		assertNull(customer, "Customer is null");		services[0] = myOrdering.getKitchen();		assertNotNull(services[0], "Kitchen is not null");		services[1] = myOrdering.getDelivery();		assertNotNull(services[1], "Delivery is not null");	}	@Test	public void testOrderingStartNewOrder() {		OrderVO order;		order = myOrdering.startNewOrder(customer);		assertNotNull(order, "return value  is not null");		assertTrue(order.equals(myOrdering.getCurrentOrder()), "CurrentOrder is set and matches the return value. ");		assertTrue(customer.equals(myOrdering.getCurrentCustomer()),				"CurrentCustomer is set and matches the parameter. ");		assertTrue(order.equals(myOrdering.getCurrentCustomer().getOrder()),				"Order in customer is set and the order. ");		assertTrue(order.getState() == StateOfOrderVO.STARTED, "State of order  is started. ");	}	@Test	public void testOrderingStartNewOrderWithNoCustomerNullPointerEception() {				Exception exception = Assertions.assertThrows(NullPointerException.class, () ->		myOrdering.startNewOrder(null));				assertEquals("Customer must not be null", exception.getMessage());	}		@Test	public void testOrderingNextIdNewYear()			throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {		int id;		Ordering myOrderingId = new Ordering();		myOrderingClass = Ordering.class;		nextId = myOrderingClass.getDeclaredField("nextId");		nextId.setAccessible(true);		nextId.set((LocalDateTime.now().getYear() - 1) * 100000 + 1, (LocalDateTime.now().getYear() - 1) * 100000 + 1);		myOrderingId.startNewOrder(customer);		id = LocalDateTime.now().getYear() * 100000 + 1;		assertTrue(id == myOrderingId.getCurrentOrder().getOrderNo(), "OrderNo of currentOrder is correct");		assertTrue(id == Ordering.getNextId(), "NextId of Ordering is correct");	}	@Test	public void testOrderingAddDishWithNoOrderNoOrderException() {				myOrdering.setCurrentOrder(null);				Exception exception = Assertions.assertThrows( NoOrderException.class, () ->		myOrdering.addDish(new DessertVO()));				assertEquals("There is no order.", exception.getMessage());	}	@Test	public void testOrderingAddDish() throws NoOrderException {		DishVO dish = new DessertVO();		OrderVO order;		order = myOrdering.startNewOrder(customer);		myOrdering.addDish(dish);		assertEquals(dish, order.getDish(0), "Dish is added");	}	@Test	public void testOrderingAddDishStateConfirmedIllegalStateException() {				DishVO dish = new DessertVO();		OrderVO order;		order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.CONFIRMED);				Exception exception = Assertions.assertThrows( IllegalStateException.class, () ->		myOrdering.addDish(dish));				assertEquals("Your order is complete, you can not add any dishes.", exception.getMessage());	}	@Test	public void testOrderingAddDishStateReadyIllegalStateException() {		DishVO dish = new DessertVO();		OrderVO order;		order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.CONFIRMED);				Exception exception = Assertions.assertThrows( IllegalStateException.class, () ->		myOrdering.addDish(dish));				assertEquals("Your order is complete, you can not add any dishes.", exception.getMessage());	}	@Test	public void testOrderingAddDishStateDeliveredIllegalStateException() {		DishVO dish = new DessertVO();		OrderVO order;		order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.CONFIRMED);				Exception exception = Assertions.assertThrows( IllegalStateException.class, () ->		myOrdering.addDish(dish));				assertEquals("Your order is complete, you can not add any dishes.", exception.getMessage());	}	@Test	public void testOrderingAddDishStateFinishedIllegalStateException() {		DishVO dish = new DessertVO();		OrderVO order;		order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.CONFIRMED);				Exception exception = Assertions.assertThrows( IllegalStateException.class, () ->		myOrdering.addDish(dish));				assertEquals("Your order is complete, you can not add any dishes.", exception.getMessage());	}	@Test	public void testOrderingAddDishNull() throws NoOrderException {		DishVO dish = null;		OrderVO order;		order = myOrdering.startNewOrder(customer);		myOrdering.addDish(dish);		assertEquals(dish, order.getDish(0), "Dish is added");	}	@Test	public void testOrderingDeleteDishWithNoOrder() {				myOrdering.setCurrentOrder(null);				Exception exception = Assertions.assertThrows( NoOrderException.class, () ->		myOrdering.deleteDish(null));				assertEquals("There is no order.", exception.getMessage());			}	@Test	public void testOrderingDeleteDish() throws NoOrderException {		DishVO dish = new DessertVO();		OrderVO order;		order = myOrdering.startNewOrder(customer);		myOrdering.addDish(dish);		assertEquals(dish, order.getDish(0), "Dish is added");		myOrdering.deleteDish(dish);		assertEquals(0, order.getNumberOfDishes(), "Dish is delete. There are no more dishes");	}	@Test	public void testOrderingDeleteDishStateConfirmedIllegalStateException() {		DishVO dish = new DessertVO();		OrderVO order;		order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.CONFIRMED);				Exception exception = Assertions.assertThrows( IllegalStateException.class, () ->		myOrdering.deleteDish(dish));				assertEquals("Your order is complete, you can not delete any dishes.", exception.getMessage());		}	@Test	public void testOrderingConfirmOrder() throws NoOrderException, NoCustomerException {				System.setOut(new PrintStream(outContent));		System.setErr(new PrintStream(errContent));					OrderVO order;		order = myOrdering.startNewOrder(customer);		myOrdering.confirmOrder();		assertEquals(StateOfOrderVO.FINISHED, order.getState(),				"State of order is finished, since service was started.");				assertTrue(outContent.toString().contains("Order completed:"), "Message is printed");		System.setOut(originalOut);		System.setErr(originalErr);	}	public void testOrderingConfirmOrderTextAmEnde() throws NoOrderException, NoCustomerException {		System.setOut(new PrintStream(outContent));		System.setErr(new PrintStream(errContent));		myOrdering.confirmOrder();		assertTrue(outContent.toString().contains("Order completed: "), "Order completed: ");		System.setOut(originalOut);		System.setErr(originalErr);	}	@Test	public void testOrderingConfirmOrderNullNoOrderException() {		myOrdering.setCurrentOrder(null);				Exception exception = Assertions.assertThrows( NoOrderException.class, () ->		myOrdering.confirmOrder());				assertEquals("There is no order.", exception.getMessage());	}			@Test	public void testOrderingStartServiceIsPrivate() throws NoSuchMethodException {		 assertTrue(Modifier.isPrivate(modifiersStartService), "Methode startSercice of Ordering is private");	}				@Test	public void testOrderingStartServiceOrderNULLNoOrderException() {				myOrdering.setCurrentOrder(null);				Exception exception = Assertions.assertThrows(NoOrderException.class, () ->ReflectionSupport.invokeMethod(startSercice, myOrdering));		assertTrue(exception.getMessage().contains("There is no order."), "Error: There is no order.");	}	@Test	public void testOrderingStartServiceStateStarted() throws NoOrderException, NoCustomerException {				myOrdering.startNewOrder(customer);				Exception exception = Assertions.assertThrows(IllegalStateException.class, () -> ReflectionSupport.invokeMethod(startSercice, myOrdering));		assertTrue(exception.getMessage().contains("The order can not be processed."), "The order can not be processed.");		}		@Test	public void testOrderingStartServiceDeliveryStateConfirmedNoCustomer() {		OrderVO order;		myOrdering.startNewOrder(customer);		order = myOrdering.getCurrentOrder();		order.setState(StateOfOrderVO.CONFIRMED);		order.setCustomer(null);				Exception exception = Assertions.assertThrows(NoCustomerException.class, () ->		ReflectionSupport.invokeMethod(startSercice, myOrdering));								assertTrue(exception.getMessage().contains("No customer available."), "No customer available. als Fehler ausgegeben.");			}		@Test	public void testOrderingStartServiceConfirmedNoCustomer() throws IllegalStateException, NoOrderException, NoCustomerException {		System.setOut(new PrintStream(outContent));		System.setErr(new PrintStream(errContent));		OrderVO order;		myOrdering.startNewOrder(customer);		order = myOrdering.getCurrentOrder();		order.setCustomer(null);	//	System.out.println(exception.getMessage());		myOrdering.confirmOrder();		assertTrue(errContent.toString().contains("Internal error by processing an order:"), "Internal error by processing an order: Exception from delivery is caught");		assertTrue(errContent.toString().contains("No customer available."), "Message of Exception is printed on error output");		System.setOut(originalOut);		System.setErr(originalErr);	}	@Test	public void testOrderingCalculateTotalPriceOrderNullNoOrderException()  {				myOrdering.setCurrentOrder(null);						Exception exception = Assertions.assertThrows( NoOrderException.class, () ->		myOrdering.calculateTotalPrice());				assertEquals("There is no order.", exception.getMessage());					}	@Test	public void testOrderingCalculateTotalPriceOrderNoDish() throws NoOrderException {		float price;		myOrdering.startNewOrder(customer);		price = myOrdering.calculateTotalPrice();		assertTrue(0.0f == price, "Price is 0.");	}	@Test	public void testOrderingCalculateTotalPriceOrderStateConfirmed() throws NoOrderException {		float price;		OrderVO order;		order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.CONFIRMED);		price = myOrdering.calculateTotalPrice();		assertTrue(0.0f == price, "Price is 0.");	}	@Test	public void testOrderingCalculateTotalPrice() throws NoOrderException {		float priceIni = 7.65f;		float price;		OrderVO order;		DishVO dish = new PizzaVO(30, "Popeye", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, priceIni, 1);		order = myOrdering.startNewOrder(customer);		myOrdering.addDish(dish);		price = myOrdering.calculateTotalPrice();		assertTrue(priceIni == price, "Total price is ok.");		order.setState(StateOfOrderVO.CONFIRMED);		price = myOrdering.calculateTotalPrice();		assertTrue(priceIni == price, "Total price is ok.");	}	@Test	public void testOrderingConfirmOrderWrongStateNoOrderException() {		myOrdering.setCurrentOrder(null);				Exception exception = Assertions.assertThrows( NoOrderException.class, () ->		myOrdering.confirmOrder());				assertEquals("There is no order.", exception.getMessage());					}		@Test	public void testOrderingConfirmOrderWrongStateIllegalStateException() {		myOrdering.startNewOrder(customer);		myOrdering.getCurrentOrder().setState(StateOfOrderVO.FINISHED);;				Exception exception = Assertions.assertThrows( IllegalStateException.class, () ->		myOrdering.confirmOrder());				assertEquals("Your order can not be confirmed.", exception.getMessage());					}		@Test	public void testOrderingSortShoppingBasket() throws NoOrderException {		List<DishVO> shoppingBasketInit, shoppingBasketSort, shoppingBasketSortExcpeted;		OrderVO order;		Ordering ordering;				shoppingBasketInit = new ArrayList<DishVO>();		shoppingBasketSortExcpeted = new ArrayList<DishVO>();				ordering = new Ordering();				order = ordering.startNewOrder(customer);				shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 1));		shoppingBasketInit.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));		shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketInit.add(new PizzaVO(30, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));				shoppingBasketSortExcpeted.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 1));				order.setShoppingBasket(shoppingBasketInit);		shoppingBasketSort = ordering.sortShoppingBasket();		assertEquals(shoppingBasketSort, shoppingBasketSortExcpeted, "Sort is correct according to total ordering, i.e. by name");	}		@Test	public void testOrderingSortShoppingBasketNoOrderException() {				myOrdering.setCurrentOrder(null);				Exception exception = Assertions.assertThrows( NoOrderException.class, () ->		myOrdering.sortShoppingBasket());				assertEquals("There is no order.", exception.getMessage());	}		@Test	public void testOrderingSortShoppingBasketByNumber() throws NoOrderException {		List<DishVO> shoppingBasketInit, shoppingBasketSort, shoppingBasketSortExcpeted;		OrderVO order;		Ordering ordering;				shoppingBasketInit = new ArrayList<DishVO>();		shoppingBasketSortExcpeted = new ArrayList<DishVO>();				ordering = new Ordering();				order = ordering.startNewOrder(customer);						shoppingBasketInit.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));		shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 1));		shoppingBasketInit.add(new PizzaVO(31, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));						shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 1));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketSortExcpeted.add(new PizzaVO(31, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketSortExcpeted.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));				order.setShoppingBasket(shoppingBasketInit);		shoppingBasketSort = ordering.sortShoppingBasketByNumber();		assertEquals(shoppingBasketSort, shoppingBasketSortExcpeted, "Sort is correct by number");	}		@Test	public void testOrderingSortShoppingBasketByNumberNoOrderException() {				myOrdering.setCurrentOrder(null);				Exception exception = Assertions.assertThrows( NoOrderException.class, () ->		myOrdering.sortShoppingBasketByNumber());				assertEquals("There is no order.", exception.getMessage());	}		@Test	public void testOrderingShoppingBasketSortByPrice() throws NoOrderException {		List<DishVO> shoppingBasketInit, shoppingBasketSort, shoppingBasketSortExcpeted;		OrderVO order;		Ordering ordering;				shoppingBasketInit = new ArrayList<DishVO>();		shoppingBasketSortExcpeted = new ArrayList<DishVO>();				ordering = new Ordering();				order = ordering.startNewOrder(customer);						shoppingBasketInit.add(new PizzaVO(31, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 8.5f, 2));		shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 7.5f, 2));		shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 6.5f, 1));		shoppingBasketInit.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));					shoppingBasketSortExcpeted.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 6.5f, 1));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 7.5f, 2));		shoppingBasketSortExcpeted.add(new PizzaVO(31, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 8.5f, 2));						order.setShoppingBasket(shoppingBasketInit);		shoppingBasketSort = ordering.sortShoppingBasketByPrice();		assertEquals(shoppingBasketSort, shoppingBasketSortExcpeted, "Sort is correct by price");	}	@Test	public void testOrderingSortShoppingBasketByPriceNoOrderException() {				myOrdering.setCurrentOrder(null);				Exception exception = Assertions.assertThrows( NoOrderException.class, () ->		myOrdering.sortShoppingBasketByPrice());				assertEquals("There is no order.", exception.getMessage());	}}